\section{Ход выполнения}
\subsection{Задание 1}

Повторить команды cat, head, tail, more, less, grep, find.

По сути, задача команды cat очень проста - она читает данные из файла или стандартного ввода и выводит их на экран. Это все, чем занимается утилита. Но с помощью ее опций и операторов перенаправления вывода можно сделать очень многое.

Рассмотрим основные основные опций команды cat:
\begin{enumerate}
    \item -b -- нумеровать только непустые строки;
    \item -E -- показывать символ \$ в конце каждой строки;
    \item -n -- нумеровать все строки;
    \item -s -- удалять пустые повторяющиеся строки;
    \item -T -- отображать табуляции в виде  \^  I;
    \item -h -- отобразить справку;
    \item -v -- версия утилиты.
\end{enumerate}

Для примера откроем какой-нибудь файл, пронумеруем все строки и покажем символ \$ в конце каждой строки. Результат выполнения представлен на рисунке \ref{cat}.

\addimg{1}{1}{Пример работы с командой cat}{cat}

Команда head выводит начальные строки (по умолчанию -- 10)  из одного или нескольких документов. Также она может показывать данные, которые передает на вывод другая утилита.

Чаще всего к команде head применяются такие опции:
\begin{enumerate}
    \item -c (--bytes) -- позволяет задавать количество текста не в строках, а в байтах. При записи в виде --bytes=[-]NUM выводит на экран все содержимое файла, кроме NUM байт, расположенных в конце документа.
    \item -n (--lines) -- п-оказывает заданное количество строк вместо 10, которые выводятся по умолчанию. Если записать эту опцию в виде --lines=[-]NUM, будет показан весь текст кроме последних NUM строк.
    \item -q (--quiet, --silent) -- выводит только текст, не добавляя к нему название файла.
    \item -v (--verbose) -- перед текстом выводит название файла.
    \item -z (--zero-terminated) -- символы перехода на новую строку заменяет символами завершения строк.
\end{enumerate}

В качестве примера выведем первые 15 строк выдаваемые командой ps -fu root. Результат выполнения представлен на рисунке \ref{head}.

\addimg{2}{1}{Пример работы с командой head}{head}

Если необходимо просмотреть не все содержимое файла, а только то, что находится в конце, то можно воспользоваться командой tail.  Она позволяет выводить заданное количество строк с конца файла, а также выводить новые строки в интерактивном режиме.

По умолчанию утилита выводит десять последних строк из файла, но ее поведение можно настроить с помощью опций:
\begin{enumerate}
    \item -c -- выводить указанное количество байт с конца файла;
    \item -f -- обновлять информацию по мере появления новых строк в файле;
    \item -n -- выводить указанное количество строк из конца файла;
    \item -pid -- используется с опцией -f, позволяет завершить работу утилиты, когда завершится указанный процесс;
    \item -q -- не выводить имена файлов;
    \item -retry -- повторять попытки открыть файл, если он недоступен;
    \item -v -- выводить подробную информацию о файле.
\end{enumerate}

Используем команду tail, чтобы просмотреть последние 15 строк выдаваемые командой ps -fu root. Результат выполнения представлен на рисунке \ref{tail}.

\addimg{3}{1}{Пример работы с командой tail}{tail}

Утилита more предназначена для постраничного просмотра файлов в терминале Linux.

Список опций команды:
\begin{enumerate}
    \item -d -- вывод информации в конце страницы о клавишах, использующихся для продолжения работы, завершения её или получения инструкций;
    \item -l -- игнорирование в тексте символа разрыва страницы;
    \item -f -- подсчёт числа логических строк вместо экранных;
    \item -p -- очистка экрана терминала для того, чтобы пользователю не пришлось пользоваться прокруткой перед выводом следующей порции текста;
    \item -c -- устранение потребности в прокрутке (как и -p) -- отображение текста, начиная с верха экрана, и стирание при этом предыдущего вывода построчно;
    \item -s -- замена нескольких пустых строк, расположенных подряд, одной пустой строкой;
    \item -u -- удаление подчёркивания;
    \item -n -- отображение n-го количества строк;
    \item +n -- отображение текста, начиная со строки с номером n;
    +/строка -- поиск в файле указанной строки и начало вывода текста именно с неё;
    \item --help -- вызов справки;
    \item -v --(--version) -- вывод на экран текущей версии утилиты.
\end{enumerate}

Также у команды more есть собственные горячие клавиши и интерактивные команды:
\begin{enumerate}
    \item h (?) -- помощь (вывод информации только об интерактивных командах);
    \item ПРОБЕЛ -- отображение следующей порции текста (по умолчанию количество строк зависит от текущего размера окна терминала);
    \item z -- то же, что и ПРОБЕЛ;
    ENTER -- вывод текста построчно (шаг команды -- одна строка);
    \item d  -- прокрутка текста на количество строк, соответствующее размеру терминала;
    \item q (Q) -- выход из утилиты;
    \item s -- переход на одну строку вперёд;
    \item f -- переход на одну экранную страницу вперёд;
    \item b -- переход на одну экранную страницу назад;
    \item ' -- возвращение к месту начала поиска;
    \item = -- отображение текущего количества строк;
    \item /pattern -- поиск с использованием регулярных выражений;
    \item n -- поиск слов и фраз, соответствующих последнему использованному регулярному выражению;
    \item !command (:command) -- выполнение команды в субоболочке;
    \item v -- открытие файла в текстовом редакторе, назначенном по умолчанию, а если таковой не найден, использование консольного текстового редактора для открытия файла;
    \item :n -- переход к следующему файлу;
    \item :p -- переход к предыдущему файлу;
    \item :f -- вывод названия текущего файла и количества строк в нём;
    \item . -- повторное выполнение предыдущей команды.
\end{enumerate}

Выведем результат выполнения команды ps -fu root постранично по 10 строк. Результат выполнения представлен на рисунке \ref{more}.

\addimg{4_1}{1}{Пример работы с командой more}{more}

Когда команда вывела часть текста и бездействует в ожидании дальнейших действий пользователя можно выполнять интерактивные команды. Они нужны для управления выводом.

Команда less позволяет перематывать текст не только вперёд, но и назад, осуществлять поиск в обоих направлениях, переходить сразу в конец или в начало файла. Особенность less заключается в том, что команда не считывает текст полностью, а загружает его небольшими фрагментами.

Наиболее популярные опции:
\begin{enumerate}
    
    \item -a, --search-skip-screen -- не осуществлять поиск в тексте, который в данный момент отображен на экране;
    \item -bn, --buffers=n -- задать размер буфера памяти;
    \item -c, --clear-screen -- листать текст, полностью стирая содержимое экрана (построчная прокрутка работать не будет);
    \item -Dxcolor, --color=xcolor -- задать цвет отображаемого текста;
    \item -E, --QUIT-AT-EOF -- выйти, когда утилита достигнет конца файла;
    \item -e, --quit-at-eof -- выйти, когда утилита второй раз достигнет конца файла;
    \item -F, --quit-if-one-screen -- выйти, если содержимое файла помещается на одном экране;
    \item -f, --force -- открыть специальный файл;
    \item -hn, --max-back-scroll=n -- задать максимальное количество строк для прокрутки назад;
    \item -yn, --max-forw-scroll=n -- задать максимальное количество строк для прокрутки вперёд;
    \item -i, --ignore-case -- игнорировать регистр;
    \item -I, --IGNORE-CASE -- игнорировать регистр, даже если паттерн для поиска содержит заглавные буквы;
    \item -jn, --jump-target=n -- указать, в какой строке должна быть выведена искомая информация;
    \item -J, --status-column -- пометить строки, соответствующие результатам поиска;
    \item -n, --line-numbers -- не выводить номера строк;
    \item -N, --LINE-NUMBERS -- вывести номера строк;
    \item -s, --squeeze-blank-lines -- заменить множество идущих подряд пустых строк одной пустой строкой;
    \item -w, --hilite-unread -- выделить первую строку нового фрагмента текста.
\end{enumerate}

Во время просмотра текста утилитой можно управлять при помощи внутренних команд, набирая их на клавиатуре компьютера. Наиболее часто используемые из них:
\begin{enumerate}
    \item h, H -- справка;
    \item Space, Ctrl+V, f, Ctrl+F -- прокрутить текст на один экран вперёд;
    \item Enter, Return, Ctrl+N, e, Ctrl+E, j, Ctrl+J -- прокрутить текст на n строк вперед, по умолчанию n=1;
    \item y, Ctrl+Y, Ctrl+P, k, Ctrl+K -- прокрутить текст на n строк назад, по умолчанию n=1;
    \item Ctrl+→ -- прокрутить текст по горизонтали в конец строки;
    \item Ctrl+← -- прокрутить текст по горизонтали в начало строки;
    \item :d -- удалить текущий файл из списка файлов;
    \item Ctrl+G, :f -- вывести основную информацию о файле;
    \item q, Q, :q, :Q, ZZ -- выход.
\end{enumerate}

Выведем с помощью команды less содержимое длинного текстового файла, убрав множественные пустые строки (используем опцию -s).
Результат выполнения представлен на рисунке \ref{less}.

\addimg{5_1}{1}{Пример работы с командой less}{less}

Во время выполнения команды less можно пользоваться интерактивными командами. Найдем вхождения слова "другой" вниз по тексту, для этого введем /другой. Результат выполнения поиска представлен на рисунке \ref{less_find}.

\addimg{5_2}{1}{Пример работы с поиском внутри команды less}{less_find}

Утилита grep решаем множество задач, в основном она используется для поиска строк, соответствующих строке в тексте или содержимому файлов. Также она может находить по шаблону или регулярным выражениям.

Основные опции команды:
\begin{enumerate}
    \item -b -- показывать номер блока перед строкой;
    \item -c -- подсчитать количество вхождений шаблона;
    \item -h -- не выводить имя файла в результатах поиска внутри файлов Linux;
    \item -i -- не учитывать регистр;
    \item -l -- отобразить только имена файлов, в которых найден шаблон;
    \item -n -- показывать номер строки в файле;
    \item -s -- не показывать сообщения об ошибках;
    \item -v -- инвертировать поиск, выдавать все строки кроме тех, что содержат шаблон;
    \item -w -- искать шаблон как слово, окружённое пробелами;
    \item -e -- использовать регулярные выражения при поиске;
    \item -An -- показать вхождение и n строк до него;
    \item -Bn -- показать вхождение и n строк после него;
    \item -Cn -- показать n строк до и после вхождения.
\end{enumerate}

Просмотрим какие python пакеты и библиотеки установлены в данной системе. Для этого с помощью команды dpkg -l получим все установленные *.deb пакеты, далее передадим вывод этой команды в grep -i python, чтобы найти все python пакеты, чтобы сократить вывод распечатаем первые 10 строк с помощью команды head. Результат выполнения представлен на рисунке \ref{grep}. 

\addimg{6}{1}{Пример работы с командой grep}{grep}

Find -- это команда для поиска файлов и каталогов на основе специальных условий. 

Основные опции команды:
\begin{enumerate}
    \item -P -- никогда не открывать символические ссылки
    \item -L -- получает информацию о файлах по символическим ссылкам. Важно для дальнейшей обработки, чтобы обрабатывалась не ссылка, а сам файл.
    \item -maxdepth -- максимальная глубина поиска по подкаталогам, для поиска только в текущем каталоге установите 1.
    \item -depth -- искать сначала в текущем каталоге, а потом в подкаталогах
    \item -mount -- искать файлы только в этой файловой системе.
    \item -version -- показать версию утилиты find
    \item -print -- выводить полные имена файлов
    \item -type f -- искать только файлы
    \item -type d -- поиск папки в Linux
\end{enumerate}

Основные критерии команды:
\begin{enumerate}
    \item -name -- поиск файлов по имени
    \item -perm -- поиск файлов в Linux по режиму доступа
    \item -user -- поиск файлов по владельцу
    \item -group -- поиск по группе
    \item -mtime -- поиск по времени модификации файла
    \item -atime -- поиск файлов по дате последнего чтения
    \item -nogroup -- поиск файлов, не принадлежащих ни одной группе
    \item -nouser -- поиск файлов без владельцев
    \item -newer -- найти файлы новее чем указанный
    \item -size -- поиск файлов в Linux по их размеру
\end{enumerate}

Найдем все скрытые файлы пользователя kirill. Для этого воспользуемся следующей командой: find ~ -type f -name ".*" -user kirill, выведем первые 10 из них с помощью команды head. Результат представлен на рисунке \ref{find}.

\addimg{7}{1}{Пример работы с командой find}{find}

\subsection{Задание 2}

Операторы перенаправления способны изменять направление вывода и ввода информации. Имеются следующие операторы перенаправления ввода/вывода:
\begin{enumerate}
    \item $>$ -- перенаправляет стандартный поток в файл (другой поток). При этом если файл существует, то он перезаписывается, если не существует – создается.
    \item $>>$  -- перенаправляет стандартный поток в файл. При этом если файл существует, то информация добавляется в конец, если не существует – файл создается.
    \item $<$ -- перенаправляет содержимое указанного файла на стандартный ввод программы.
    \item $>$\&  -- перенаправляет стандартные потоки вывода и ошибок друг в друга.
\end{enumerate}

Конвейер (англ. pipeline) в терминологии операционных систем семейства Unix — некоторое множество процессов, для которых выполнено следующее перенаправление ввода-вывода: то, что выводит на поток стандартного вывода предыдущий процесс, попадает в поток стандартного ввода следующего процесса. Конвейеры имеют следующий синтаксис <команда> | <команда> | ... | <команда>.

Воспользуемся конвейерами, чтобы перенаправит вывод команды ls -l в команду sort, а затем перенаправим вывод sort в файл. Резудьтат представлен на рисунке \ref{pipe_io}.

\addimg{8}{1}{Пример работы с конвейрами и перенапрвлением вывода}{pipe_io}

\newpage
\subsection{Задание 3}

\addimg{9}{1}{Пример работы с командой chmod}{chmod}

Создадим файл chmod.txt с правами суперпользователя root, для этого выполним команду sudo touch chmod.txt. Теперь с помощью команды cat попробуем записать что-нибудь в этот файл, как видно на рисунке \ref{chmod} нам отказано в доступе, т.к. у пользователя kirill нет прав на запись в этот файл. Чтобы исправить данную ситуацию выдадим ему эти права с помощью команды sudo chmod o+w chmod.txt. Произведем еще одну тестовую запись, которая теперь происходит успешно. 

Теперь воспользуемся командой chown, чтобы изменить владельца файла chmod.txt на пользователя kirill. Для этого используем команду sudo chown kirill chmod.txt. Результат выполнения команды chown, а также информация о владении файлом представлена на рисунке \ref{chown}.

\addimg{10}{1}{Пример работы с командой chown}{chown}

\subsection{Задание 4}

Выведем в терминал все процессы, запущенные в данный момент с помощью команды top. результат представлен на рисунке \ref{top}.

\addimg{11}{1}{Процессы выполняемые в данный момент}{top}

Теперь отсортируем процессы по полю PID, для этого во время выполнения команды top нажмем комбинацию клавиш Shift+F, затем выберем из предложенного списка PID, подтвердим выбор нажатием клавиши s и выйдем из текущего окна, нажав клавишу q. Страница выбора поля для сортировки представлено на рисунке \ref{top_sel}, результат сортировки представлен на рисунке \ref{top_sort}.

\addimg{12_1}{1}{Страница выбора поля для сортировки}{top_sel}
\addimg{12_2}{1}{Процессы, отсортированные по PID}{top_sort}

Выведем все процессы пользователя kirill, для этого выполним команду top -u kirill. Результат выполнения данной команды представлен на рисунке \ref{top_user}.

\addimg{13}{1}{Процессы пользователя kirill}{top_user}

Выделим процессы, которые выполняются в данный момент. Для этого во время выполнения команды top необходимо нажать клавишу z. Результат выполнения представлен на рисунке \ref{top_hl}.

\addimg{14}{1}{Выделение выполняемых процессов}{top_hl}

Чтобы отобразить абсолютные пути запущенных процессов, необходимо во время выполнения команды top нажать клавишу c. Результат выполнения представлен на рисунке \ref{top_abs}.

\addimg{15}{0.8}{Вывод абсолютых путей процессов}{top_abs}

Чтобы поменять интервал обновления списка процессов, необходимо во время выполнения команды top нажать клавишу d и ввести новое значение времени обновления. Результат выполнения представлен на рисунке \ref{top_ref}.

\addimg{16}{1}{Изменение интервала оновления}{top_ref}

Чтобы послать процессу какой-либо сигнал, необходимо во время выполнения команды top нажать клавишу k, затем ввести PID целевого процесса и сигнал, который необходимо отомлать. Результат выполнения представлен на рисунках \ref{top_kill_pid} и \ref{top_kill_sign}.

\addimg{17_1}{1}{Выбор процесса для посылки сигнала}{top_kill_pid}
\addimg{17_2}{1}{Выбор сиганла для посылки процессу}{top_kill_sign}

Чтобы отсортировать процессы по нагрузке на процессор, необходимо во время выполнения команды top нажать комбинацию клавиш Shift+p. Результат выполнения представлен на рисунке \ref{top_cpu}.

\addimg{18}{1}{Процессы отсортированные по нагрузке на CPU}{top_cpu}

Чтобы изменить приоритет процесса, необходимо во время выполнения команды top нажать клавишу r, затем ввести PID процесса и новый приоритет. Для примера установим процессу с PID=3535 приоритет равный 8. Результат выполнения представлен на рисунках \ref{top_pr_b} и \ref{top_pr_a}.

\addimg{19_1}{1}{Процессы до установки нового приоритета}{top_pr_b}
\addimg{19_2}{1}{Процессы после установки нового приоритета}{top_pr_a}

Чтобы сохранить список выполняемых процессов в файл воспользуемся перенаправлением ввода/вывода. Для этого выполним следующую команду: top -n 1 -b > top-output.txt. Затем выведем первые 10 строк полученного файла с помощью команды head. Результат выполнения представлен на рисунке \ref{top_file}.

\addimg{20}{1}{Перенаправление вывода команды top}{top_file}

Чтобы получить справку по команде top, необходимо во время выполнения команды top нажать клавишу h. Результат выполнения представлен на рисунке \ref{top_help}.

\addimg{21}{0.8}{Справка по команде top}{top_help}

Вывод команды top будет обновляться пока не будет нажата клавиша q, чтобы выполнение прекратилось после определенного числа обновлений можно воспользоваться опцией -n <число>.

Теперь разберемся с запуском процессов в supervision. Для начала установим sypervisor, для этого выполним команду sudo apt install supervisor. Процесс установки представлен на рисунке \ref{sv_inst}.

\addimg{22}{1}{Установка supervisor}{sv_inst}

Для тестирования запуска процессов в supervision создадим bash скрипт, который будет выводить слово Hello каждые 5 секунд. Результат создания скрипта представлен на рисунке \ref{bash}.

\addimg{23}{1}{Скрипт для тестирования}{bash}

Теперь произведем конфигурацию supervisor и добавим созданный скрипт, чтобы он управлял им. Файл конфигурации по умолчанию находится в /etc/supervisor/supervisord.conf. В данном файле представлены следующие параметры:
\begin{enumerate}
    \item [program:worker] — название процесса/воркера, к которому будут относиться все последующие параметры секции;
    \item command= — команда на запуск файла, то есть путь к нужному файлу;
    \item stdout\_logfile= — вывод консоли в файл;
    \item autostart= — запуск воркера вместе с запуском supervisor;
    \item autorestart= — перезапуск воркера, если тот по какой-то причине упал;
    \item user= — запуск процесса под определенным пользователем;
    \item stopsignal= — сигнал остановки (убийства) процесса. Если не определяется, то используется команда по умолчанию — TERM;
    \item numprocs= — количество инстансов заданного воркера
\end{enumerate}

Теперь откроем наш файл и сконфигурируем его для запуска написанного скрипта. Результат выполнения представлен на рисунке \ref{sv_conf}.  

\addimg{24}{1}{Конфигурация superviror}{sv_conf}

После добавления процесса перезапустим supervisor командой: /etc/init.d/supervisor restart. После перезапуска посмотрим на содержимое файла логгирования. Результат выполнения представлен на рисунке \ref{sv_log}.

\addimg{25}{1}{Лог файл выполняемого процесса}{sv_log}

\subsection{Задание 5}
Для запуска процессов по расписанию используется команда cron. Cron – программа-демон, предназначенная для выполнения заданий в определенное время, или через определенные промежутки времени. Для редактирования заданий используется утилита crontab. 

Чтобы задать расписание для процесса выполним команду crontab -e, в открывшемся текстовом редакторе запишем расписание и команду, сделаем так, чтобы каждые 10 минут выполнялся снимок экрана, для этого запишем строку */10 * * * * scrot, затем проверим, что изменения успешно вступили в силу с помощью команды crontab -l. Результат выполнения представлен на рисунке \ref{cron}.

\addimg{26}{1}{Создания расписания с помощью cron}{cron}