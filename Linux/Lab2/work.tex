\section{Ход выполнения}
\subsection{Часть 1}

На рисунке \ref{user} продемонстрирована загрузка в режиме обычнного пользователя.
\addimg{1}{1}{Загрузка в режиме пользователя}{user}

На рисунке \ref{kernel} произведен переход в корневую дирректорию и показана информация о файле ядра.
\addimg{2}{1}{Файл ядра Linux}{kernel}

По названию файла ядра с рисунка \ref{kernel} видно, что версия ядра -- 5.4.0.51

На рисунке \ref{ps} показан вывод всех текущих процессов Linux в текщей обочке с помощью утилиты ps. Добавление опции -f дает возможность вывести максимум доступных данных.
\addimg{3}{1}{Процессы в текущей оболочке}{ps}

На рисунке \ref{ps} мы видим два запущенных процесса, проанализируем полученную информацию, используя файл справки:

\begin{enumerate}
    \item UID -- пользователь, от имени которого запущен процесс;
    \item PID -- идентификатор процесса;
    \item PPID -- идентификатор родительского процесса;
    \item С -- процент времени CPU, используемого процессом;
    \item STIME -- время запуска процесса;
    \item TTY -- терминал, из которого запущен процесс;
    \item TIME -- общее время процессора, затраченное на выполнение процессора;
    \item CMD -- команда запуска процессора;
\end{enumerate}

Создадим два сценария loop и loop2 с помощью редактора vim, процесс создания продемонстрирован на рисунках \ref{loop_cr} и \ref{loop2_cr}.

\addimg{4_1}{1}{Создание сценария loop}{loop_cr}
\addimg{4_2}{1}{Создание сценария loop2}{loop2_cr}

На рисунке \ref{loops_ls} показан результат созлания сценариев.
\addimg{4_3}{1}{Результат создания сценариев}{loops_ls}

Как видно из рисунка \ref{loops_ls} файлы созданы, но для них не указаны права на исполнение. Добавим эти права с помощью команды chmod. Результат представлен на рисунке \ref{loops_chmod}.

\addimg{4_4}{1}{Добавление прав на исполнение}{loops_chmod}

Теперь оба процесса можно запустить на исполнение.

Запустим процесс loop2 с помощью команды sh. результат запуска продемонстрирован на рисунке
\ref{loop2_sh}.
\addimg{5}{1}{Запущенный процесс loop2}{loop2_sh}

Чтобы послать процессу сигнал STOP нажмем комбинацию клавиш Ctrl+Z. Результат виден на рисунке \ref{loop2_stop}.

\addimg{6}{0.9}{Сигнал STOP для процесса loop2}{loop2_stop}

Теперь несколько раз выполним команду ps -f (рисунок \ref{loop2_ps}).

\addimg{7}{1}{Последовательный запуск команд ps -f}{loop2_ps}

Как видно из рисунка \ref{loop2_ps} у процесса loop2 меняется значение параметра C, т.е. процент времени CPU, используемого процессом. Т.к. мы послали сигнал STOP процесс был приостановлен, но не завершен, поэтому он отсается в выводе ps -f, но постепенно перестает занимать процессорное время. Данный процесс можно возобновить послав сигнал CONT.

Теперь завершим процесс loop2 ипользую команду kill -9 (рисунок \ref{loop2_kill}).

\addimg{8}{1}{Завершение процесса loop2}{loop2_kill}

Как видно из рисунка \ref{loop2_kill} процесс loop2 был завершен, об этом свидетельствует сообщение от утилиты ps. Однако сигнал KILL завершает его не удостоверившись в его корректном завершении, что во многих случаях может приводить к ошибкам.

Запустим процесс loop в фоне с помощью команды sh loop.sh\& и посмотрим, что выдает последовательный запуск команды ps -f (рисунок \ref{loop_sh}).

\addimg{9}{1}{Запуск процесса loop в фоне}{loop_sh}

Как видно из рисунке \ref{loop_sh} видно, что процесс запущенный в фоне продолжает занимать большой процент процессорного времени.

Теперь завершим процесс loop и посмотрим, что выдаст команда ps -f(рисунок \ref{loop_term}).

\addimg{10}{0.70}{Завершение процесса loop сигналом TERM}{loop_term}

Как видно из рисунка \ref{loop_term} процесс был завершен, при чем завершен после корректного завершения выполнения процесса, т.к. мы послали сигнал TERM, а не KILL.

Теперь запустим процесс loop фоне и "убьем" его командой kill -9 (рисунок \ref{loop_kill}).

\addimg{11}{1}{Завершение процесса loop сигналом KILL}{loop_kill}

Как видно из вывода команды ps -f на рисунке \ref{loop_kill} процесс loop был именно "убит", не дожидаясь корректного завершения выполнения.

Запустим еще один экземпляр bash, результат продемонстрирован на рисунке \ref{new_bash}.

\addimg{12}{1}{Запуск еще одного экземпляра bash}{new_bash}

Запустим несколько процессов loop в фоне, результат продемонстрирован на рисунке \ref{loops_sh}.

\addimg{13_1}{1}{Запуск нескольких процессов loop в фоне}{loops_sh}

Как видно из рисунка \ref{loops_sh} родительсим процессом для новых loop является новый экземпляр bash.

 Теперь остановим эти процессы, послав им сигнал STOP, с помощью команды kill -19. Затем возобновим эти процессы, послав сигнал CONT, с помощью команды kill -18. После посылок сигналов будем распечатывать процессы командой ps -f. Последовательность выполенения продемонстрирована на рисунке \ref{loops_stop_start}.

 \addimg{13_2}{1}{Остановка и возобнослвение процессов}{loops_stop_start}

 Как видно из рисунка \ref{loops_stop_start} после выполнения команды kill -19 процессы приостанавливаются о чем свидетельствует уменьшение процента затрачиваемого процессорного времени. После выполнения команды kill -18 процессы возобновляется, о чем свидетельствует увеличение процента затрачиваемого процессорного времени.

 \subsection{Часть 2}

 Запустим 3 процесса loop: 2 в интерактивном режиме (PID 2988 и 2989) и 1 (PID 2990) в фоновом. Процесс запуска и результат выполнения команды представлены на рисунке \ref{3_loops}.

 \addimg{14}{1}{Запуск 3-х процессов}{3_loops}

Переведем 1 из процессов в фоновый режим с помощью команды bg, указав номер процесса из вывода команды jobs (рисунок \ref{loop2bg}).

\addimg{15}{1}{Перевод процесса в фоновый режим}{loop2bg}

Поэкспериментируем с переводом процессов в разные режимы работы. Переведем процесс 3 в интерактивный режим, затем переведем процесс 2 в фоновый режим. Результат выполнения представлен на рисунке \ref{loops_exp}.

\addimg{16}{1}{Перевод процессов в различные режимы работы}{loops_exp}

Для создания именованного канала воспользуемся командой mkfifo. После его создания мы можем организовать связь между выводами и вводами различных процессов. С помощью полученного канала сделаем так, чтобы утилита для архивирования gzip получала ввод из канала и выводила результат в файл result (рисунок \ref{zip_ch}).

\addimg{17_1_1}{0.90}{Создание именованного канала для архивироавния данных}{zip_ch}

Теперь откроем второй терминал и передадим в канал список содержимое домашнего каталога и его подкаталогов с помощью команды ls -R (рисунок \ref{ls_R}).

\addimg{17_1_2}{1}{Передача в канал для архивирования список содержимого домашнего каталога}{ls_R}

Вернемся в 1-ый терминал, чтобы посмотреть содержимое файла result. Для просмотра содержимого архивированного файла воспользуемся командой zcat. Результат выполнения представлен на рисунке \ref{zcat_result}.

\addimg{17_1_3}{0.95}{Содержипое файла result}{zcat_result}

Для выполнения следующего задания подготовим тестовый каталог, поместив в него несколько файлов и подкаталог. Для создания каталогов воспользуемся командой mkdir, для создания файлов командой touch, для перемещения между каталогами используем команду cd. Процесс создания тестового каталога представлен на рисунке \ref{test_dir}.

\addimg{17_2_1}{1}{Создание тестового каталога}{test_dir}

Теперь выполним аналогичные предыдущему заданию действия. Создадим новое соединение и передадим туда список содержимого тестового каталога. Создание нового соединения представлено на рисунке \ref{dir_ch}.

\addimg{17_2_2}{1}{Создание нового соединения}{dir_ch}

Теперь из второго терминала предадим список содержимого тестового каталога с помощью команды ls -l (рисунок \ref{test_ls_l}).

\addimg{17_2_3}{1}{Передача списка содержимого тестового каталога}{test_ls_l}

Перейдем в первый терминал и посмотрим содержимое файла res\_dir с помощью утилиты zcat (рисунок \ref{res_dir}).

\addimg{17_2_4}{1}{Содержимое файла res\_dir}{res_dir}

\subsection{Часть 3 (вариант 10)}

Чтобы просмотреть процессы в реальном времени воспользуемся командой top. Чтобы отсортировать процессы по PID необходимо передать команде top опцию -o и указать по какому параметру необходимо выполнить сортировку, в данном случае -- PID. Выполняемая команжа представлена на рисунке \ref{top_cmd}.

\addimg{18_1}{1}{Команда для отоображения процессов в реальном времени отсортированных по PID}{top_cmd}

Результат выполнения данной команды представлен на рисунке \ref{top_run}. 

\addimg{18_2}{0.8}{Запущенная команда top}{top_run}

Чтобы отсановить процесс во время работы команды top, неоходимо нажать клавишу k, затем ввести PID процесса, после этого можно ввести какой сигнал подать процессу (по умолчанию подается сигнал TERM). Процесс выполнения вышеуказанных действий продемонстрирован на рисунках \ref{top_k} и \ref{top_sig}.

\addimg{18_3}{1}{Вызов команды для отправки сигнала процессу и указание PID}{top_k}
\addimg{18_4}{1}{Указание сигнала для выбранного процесса}{top_sig}

Для определения последнего процесса запущенного текущим пользователем передадим команде top опции -o -TIME+ -- сортировка по возрастанию процессорного времени и -u kirill -- вывод процессов только пользователя kirill (рисунок \ref{top_start}).
\addimg{19_1}{1}{Вывод процессов пользователя kirill по возрастанию времени запуска}{top_start}

Теперь в 1-ой строке указан последний процесс запущенный пользователем, чтобы послать ему сигнал необходимо нажать клавишу k, ввести PID процесса и сигнал, который необходимо ему передать. Выполнение данной последовательности действий представлено на рисунках \ref{top_kill_PID} и \ref{top_sigkill}.
\addimg{19_2}{1}{Ввод PID процесса для остановки}{top_kill_PID}

\addimg{19_3}{1}{Ввод сигнала, отсылаемого процессу}{top_sigkill}

На рисунке \ref{top_kill_result} видно, что процесс был завершен.
\addimg{19_4}{1}{Результат отправки сигнала}{top_kill_result}

Для вывода инфорамции о работающем в системе пользователе воспользуемся командой w, эта команда выводит следующую информацию:
\begin{enumerate}
    \item USER – имя учетной записи;
    \item TTY – название терминала;
    \item FROM – имя хоста или IP адрес, с которого пользователь вошел в систему под конкретной учетной записью;
    \item LOGIN – время, когда та или иная учетная запись впервые с момента включения машины зарегистрировалась в системе;
    \item IDLE – время, когда пользователь проявил активность с определенного аккаунта (время простоя);
    \item JCPU – время, использованное всеми процессами, запущенными в терминале tty;
    \item PCPU – время, использованное текущим процессом (каким именно — можно посмотреть в столбце WHAT);
    \item WHAT – текущие процессы и команды, которыми занят пользователь под конкретной учетной записью.
\end{enumerate}

Результат выполнения данной команды представлен на рисунке \ref{user_inf}.

\addimg{20}{1}{Информация о работающем в системе пользователе}{          user_inf}

